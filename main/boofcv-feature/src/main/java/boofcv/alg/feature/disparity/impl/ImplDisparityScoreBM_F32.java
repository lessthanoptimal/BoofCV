/*
 * Copyright (c) 2011-2019, Peter Abeles. All Rights Reserved.
 *
 * This file is part of BoofCV (http://boofcv.org).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package boofcv.alg.feature.disparity.impl;

import boofcv.alg.InputSanityCheck;
import boofcv.alg.feature.disparity.DisparityBlockMatch;
import boofcv.alg.feature.disparity.DisparitySelect;
import boofcv.concurrency.BoofConcurrency;
import boofcv.concurrency.IntRangeObjectConsumer;
import boofcv.struct.image.GrayF32;
import boofcv.struct.image.ImageGray;
import boofcv.struct.image.ImageType;
import org.ddogleg.struct.FastQueue;

import javax.annotation.Generated;

/**
 * <p>
 * Implementation of {@link boofcv.alg.feature.disparity.DisparityScoreSadRect} for processing
 * input images of type {@link GrayF32}.
 * </p>
 * <p>
 * DO NOT MODIFY. This code was automatically generated by GenerateDisparityScoreBM_SAD.
 * <p>
 * 
 * @author Peter Abeles
 */
@Generated("boofcv.alg.feature.disparity.impl.GenerateDisparityScoreBM_SAD")
public class ImplDisparityScoreBM_F32<DI extends ImageGray<DI>>
	extends DisparityBlockMatch<GrayF32,DI>
{
	// Computes disparity from scores. Concurrent code copies this
	DisparitySelect<float[], DI> disparitySelect0;

	BlockRowScore<GrayF32,float[]> scoreRows;

	// reference to input images;
	GrayF32 left, right;
	DI disparity;

	FastQueue workspace = new FastQueue<>(WorkSpace.class, WorkSpace::new);
	ComputeBlock computeBlock = new ComputeBlock();

	public ImplDisparityScoreBM_F32(int minDisparity , int maxDisparity,
									int regionRadiusX, int regionRadiusY,
									BlockRowScore<GrayF32,float[]> scoreRows,
									DisparitySelect<float[], DI> computeDisparity) {
		super(minDisparity,maxDisparity,regionRadiusX,regionRadiusY);

		this.scoreRows = scoreRows;
		this.disparitySelect0 = computeDisparity;
		workspace.grow();
	}

	@Override
	public void _process(GrayF32 left , GrayF32 right , DI disparity ) {
		InputSanityCheck.checkSameShape(left,right);
		disparity.reshape(left.width,left.height);
		this.left = left;
		this.right = right;
		this.disparity = disparity;

		if( BoofConcurrency.USE_CONCURRENT ) {
			BoofConcurrency.loopBlocks(0,left.height,regionHeight,workspace,computeBlock);
		} else {
			computeBlock.accept((WorkSpace)workspace.get(0),0,left.height);
		}
	}

	class WorkSpace {
		// stores the local scores for the width of the region
		float[] elementScore;
		// scores along horizontal axis for current block
		// To allow right to left validation all disparity scores are stored for the entire row
		// size = num columns * maxDisparity
		// disparity for column i is stored in elements i*maxDisparity to (i+1)*maxDisparity
		float[][] horizontalScore = new float[0][0];
		// summed scores along vertical axis
		// This is simply the sum of like elements in horizontal score
		float[] verticalScore = new float[0];

		DisparitySelect<float[], DI> computeDisparity;

		public void checkSize() {
			if( horizontalScore.length != regionHeight || horizontalScore[0].length != lengthHorizontal ) {
				horizontalScore = new float[regionHeight][lengthHorizontal];
				verticalScore = new float[lengthHorizontal];
				elementScore = new float[ left.width ];
			}
			if( computeDisparity == null ) {
				computeDisparity = disparitySelect0.concurrentCopy();
			}
			computeDisparity.configure(disparity,minDisparity,maxDisparity,radiusX);
		}
	}

	private class ComputeBlock implements IntRangeObjectConsumer<WorkSpace> {
		@Override
		public void accept(WorkSpace workspace, int minInclusive, int maxExclusive) {

			workspace.checkSize();

			// The image border will be skipped, so it needs to back track some
			int row0 = Math.max(0,minInclusive-radiusY);
			int row1 = Math.min(left.height,maxExclusive+radiusY);

			// initialize computation
			computeFirstRow(row0, workspace.computeDisparity,
					workspace.elementScore, workspace.horizontalScore, workspace.verticalScore);

			// efficiently compute rest of the rows using previous results to avoid repeat computations
			computeRemainingRows(row0,row1, workspace.computeDisparity,
					workspace.elementScore, workspace.horizontalScore, workspace.verticalScore);
		}
	}

	/**
	 * Initializes disparity calculation by finding the scores for the initial block of horizontal
	 * rows.
	 */
	private void computeFirstRow(int row0 , DisparitySelect<float[], DI> computeDisparity,
								 final float[] elementScore, final float[][] horizontalScore, final float[] verticalScore) {
		final GrayF32 left = this.left, right = this.right;
		// compute horizontal scores for first row block
		for( int row = 0; row < regionHeight; row++ ) {
			final float[] scores = horizontalScore[row];
			scoreRows.scoreRow(left, right,row0+row, scores,
					minDisparity,maxDisparity,regionWidth,elementScore);
		}

		// compute score for the top possible row
		for( int i = 0; i < lengthHorizontal; i++ ) {
			float sum = 0;
			for( int row = 0; row < regionHeight; row++ ) {
				sum += horizontalScore[row][i];
			}
			verticalScore[i] = sum;
		}

		// compute disparity
		computeDisparity.process(row0+radiusY, verticalScore);
	}

	/**
	 * Using previously computed results it efficiently finds the disparity in the remaining rows.
	 * When a new block is processes the last row/column is subtracted and the new row/column is
	 * added.
	 */
	private void computeRemainingRows(int row0 , int row1,
									  DisparitySelect<float[], DI> computeDisparity,
									  final float[] elementScore, final float[][] horizontalScore, final float[] verticalScore )
	{
		final GrayF32 left = this.left, right = this.right;
		for( int row = row0+regionHeight; row < row1; row++ ) {
			int oldRow = (row-row0)%regionHeight;

			// subtract first row from vertical score
			final float[] scores = horizontalScore[oldRow];
			for( int i = 0; i < lengthHorizontal; i++ ) {
				verticalScore[i] -= scores[i];
			}

			scoreRows.scoreRow(left, right, row, scores, minDisparity,maxDisparity,regionWidth,elementScore);

			// add the new score
			for( int i = 0; i < lengthHorizontal; i++ ) {
				verticalScore[i] += scores[i];
			}

			// compute disparity
			computeDisparity.process(row - regionHeight + 1 + radiusY, verticalScore);
		}
	}

	@Override
	public ImageType<GrayF32> getInputType() {
		return ImageType.single(GrayF32.class);
	}

	@Override
	public Class<DI> getDisparityType() {
		return disparitySelect0.getDisparityType();
	}

}
