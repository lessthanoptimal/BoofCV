/*
 * Copyright (c) 2011-2019, Peter Abeles. All Rights Reserved.
 *
 * This file is part of BoofCV (http://boofcv.org).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package boofcv.alg.feature.disparity.block.impl;

import boofcv.alg.feature.disparity.DisparityBlockMatch;
import boofcv.alg.feature.disparity.block.BlockRowScore;
import boofcv.alg.feature.disparity.block.DisparitySelect;
import boofcv.concurrency.BoofConcurrency;
import boofcv.concurrency.IntRangeObjectConsumer;
import boofcv.struct.image.GrayU8;
import boofcv.struct.image.ImageBase;
import boofcv.struct.image.ImageGray;
import boofcv.struct.image.ImageType;
import org.ddogleg.struct.FastQueue;

import javax.annotation.Generated;

/**
 * <p>
 * Implementation of {@link boofcv.alg.feature.disparity.DisparityScoreSadRect} for processing
 * input images of type {@link GrayU8}.
 * </p>
 * <p>
 * DO NOT MODIFY. This code was automatically generated by GenerateDisparityScoreBM_SAD.
 * <p>
 * 
 * @author Peter Abeles
 */
@Generated("boofcv.alg.feature.disparity.impl.GenerateDisparityScoreBM_SAD")
public class ImplDisparityScoreBM_S32<T extends ImageBase<T>,DI extends ImageGray<DI>>
	extends DisparityBlockMatch<T,DI>
{
	// Computes disparity from scores. Concurrent code copies this
	DisparitySelect<int[], DI> disparitySelect0;

	BlockRowScore<T,int[]> scoreRows;

	// reference to input images;
	T left, right;
	DI disparity;

	FastQueue workspace = new FastQueue<>(WorkSpace.class, WorkSpace::new);
	ComputeBlock computeBlock = new ComputeBlock();

	public ImplDisparityScoreBM_S32(int minDisparity , int maxDisparity,
									int regionRadiusX, int regionRadiusY,
									BlockRowScore<T,int[]> scoreRows,
									DisparitySelect<int[], DI> computeDisparity) {
		super(minDisparity,maxDisparity,regionRadiusX,regionRadiusY);

		this.scoreRows = scoreRows;
		this.disparitySelect0 = computeDisparity;
		workspace.grow();
	}

	@Override
	public void _process(T left , T right , DI disparity ) {
		this.left = left;
		this.right = right;
		this.disparity = disparity;

		scoreRows.setInput(left,right);

		if( BoofConcurrency.USE_CONCURRENT ) {
			BoofConcurrency.loopBlocks(0,left.height,regionHeight,workspace,computeBlock);
		} else {
			computeBlock.accept((WorkSpace)workspace.get(0),0,left.height);
		}
	}

	class WorkSpace {
		// stores the local scores for the width of the region
		int[] elementScore;
		// scores along horizontal axis for current block
		// To allow right to left validation all disparity scores are stored for the entire row
		// size = num columns * maxDisparity
		// disparity for column i is stored in elements i*maxDisparity to (i+1)*maxDisparity
		int[][] horizontalScore = new int[0][0];
		// summed scores along vertical axis
		// This is simply the sum of like elements in horizontal score
		int[] verticalScore = new int[0];
		int[] verticalScoreNorm = new int[0];

		DisparitySelect<int[], DI> computeDisparity;

		public void checkSize() {
			if( horizontalScore.length != regionHeight || horizontalScore[0].length != lengthHorizontal ) {
				horizontalScore = new int[regionHeight][lengthHorizontal];
				verticalScore = new int[lengthHorizontal];
				if( scoreRows.isRequireNormalize() )
					verticalScoreNorm = new int[lengthHorizontal];
				elementScore = new int[ left.width ];
			}
			if( computeDisparity == null ) {
				computeDisparity = disparitySelect0.concurrentCopy();
			}
			computeDisparity.configure(disparity,minDisparity,maxDisparity,radiusX);
		}
	}

	private class ComputeBlock implements IntRangeObjectConsumer<WorkSpace> {
		@Override
		public void accept(WorkSpace workspace, int minInclusive, int maxExclusive) {

			workspace.checkSize();

			// The image border will be skipped, so it needs to back track some
			int row0 = Math.max(0,minInclusive-radiusY);
			int row1 = Math.min(left.height,maxExclusive+radiusY);

			// initialize computation
			computeFirstRow(row0, workspace.computeDisparity,
					workspace.elementScore, workspace.horizontalScore, workspace.verticalScore, workspace.verticalScoreNorm);

			// efficiently compute rest of the rows using previous results to avoid repeat computations
			computeRemainingRows(row0,row1, workspace.computeDisparity,
					workspace.elementScore, workspace.horizontalScore, workspace.verticalScore, workspace.verticalScoreNorm);
		}
	}

	/**
	 * Initializes disparity calculation by finding the scores for the initial block of horizontal
	 * rows.
	 */
	private void computeFirstRow(int row0 , DisparitySelect<int[], DI> computeDisparity,
								 final int[] elementScore, final int[][] horizontalScore,
								 final int[] verticalScore, final int[] verticalScoreNorm) {
		final T left = this.left, right = this.right;
		// compute horizontal scores for first row block
		for( int row = 0; row < regionHeight; row++ ) {
			final int[] scores = horizontalScore[row];
			scoreRows.scoreRow(row0+row, scores,minDisparity,maxDisparity,regionWidth,elementScore);
		}

		// compute score for the top possible row
		for( int i = 0; i < lengthHorizontal; i++ ) {
			int sum = 0;
			for( int row = 0; row < regionHeight; row++ ) {
				sum += horizontalScore[row][i];
			}
			verticalScore[i] = sum;
		}

		// compute disparity
		if( scoreRows.isRequireNormalize() ) {
			scoreRows.normalizeRegionScores(row0 + radiusY, verticalScore, minDisparity, maxDisparity, regionWidth, regionHeight, verticalScoreNorm);
			computeDisparity.process(row0 + radiusY, verticalScoreNorm);
		} else {
			computeDisparity.process(row0 + radiusY, verticalScore);
		}
	}

	/**
	 * Using previously computed results it efficiently finds the disparity in the remaining rows.
	 * When a new block is processes the last row/column is subtracted and the new row/column is
	 * added.
	 */
	private void computeRemainingRows(int row0 , int row1,
									  DisparitySelect<int[], DI> computeDisparity,
									  final int[] elementScore, final int[][] horizontalScore,
									  final int[] verticalScore , final int[] verticalScoreNorm )
	{
		final T left = this.left, right = this.right;
		for( int row = row0+regionHeight; row < row1; row++ ) {
			int oldRow = (row-row0)%regionHeight;

			// subtract first row from vertical score
			final int[] scores = horizontalScore[oldRow];
			for( int i = 0; i < lengthHorizontal; i++ ) {
				verticalScore[i] -= scores[i];
			}

			scoreRows.scoreRow(row, scores,minDisparity,maxDisparity,regionWidth,elementScore);

			// add the new score
			for( int i = 0; i < lengthHorizontal; i++ ) {
				verticalScore[i] += scores[i];
			}

			// compute disparity
			if( scoreRows.isRequireNormalize() ) {
				scoreRows.normalizeRegionScores(row - regionHeight + 1 + radiusY,
						verticalScore,minDisparity,maxDisparity,regionWidth,regionHeight,verticalScoreNorm);
				computeDisparity.process(row - regionHeight + 1 + radiusY, verticalScoreNorm);
			} else {
				computeDisparity.process(row - regionHeight + 1 + radiusY, verticalScore);
			}
		}
	}

	@Override
	public ImageType<T> getInputType() {
		return scoreRows.getImageType();
	}

	@Override
	public Class<DI> getDisparityType() {
		return disparitySelect0.getDisparityType();
	}

}
