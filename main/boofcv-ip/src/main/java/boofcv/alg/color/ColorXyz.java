/*
 * Copyright (c) 2011-2020, Peter Abeles. All Rights Reserved.
 *
 * This file is part of BoofCV (http://boofcv.org).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package boofcv.alg.color;

import boofcv.alg.color.impl.ImplColorXyz;
import boofcv.alg.color.impl.ImplColorXyz_MT;
import boofcv.concurrency.BoofConcurrency;
import boofcv.struct.image.GrayF32;
import boofcv.struct.image.GrayU8;
import boofcv.struct.image.ImageGray;
import boofcv.struct.image.Planar;

/**
 * <p>Color conversion between CIE XYZ and R'G'B' color models.</p>
 * <p>R'G'B' is a gamma corrected RGB normalized to fit in a range of 0:1</p>
 * <p>The XYZ color space is an international standard
 * developed by the CIE (Commission Internationale de lâ€™Eclairage). This model is based on three hypothetical
 * primaries, XYZ, and all visible colors can be represented by using only positive values of X, Y, and Z.
 * The CIE XYZ primaries are hypothetical because they do not correspond to any real light wavelengths.
 * The Y primary is intentionally defined to match closely to luminance, while X and Z primaries give
 * color information. The main advantage of the CIE XYZ space (and any color space based on it) is
 * that this space is completely device-independent.<br>
 * </p>
 *
 * <p>The above text is and equations below are copied from [1], which cites [2] as their source.
 *
 * <p>
 * The luminance intensity generated by most displays is not a linear function of the applied signal but is
 * proportional to some power (referred to as gamma) of the signal voltage. As a result, high intensity ranges are
 * expanded and low intensity ranges are compressed. This nonlinearity must be compensated to achieve correct color
 * reproduction. To do this, luminance of each of the linear red, green, and blue components is reduced to a nonlinear
 * form using an inverse transformation. This process is called "gamma correction".
 * </p>
 *
 * <p>See [3]</p>
 *
 * <ol>
 * <li> <a href="http://software.intel.com/sites/products/documentation/hpc/ipp/ippi/ippi_ch6/ch6_color_models.html">
 *     Intel IPP Color Models</a></li>
 * <li>David Rogers. Procedural Elements for Computer Graphics. McGraw-Hill, 1985.</li>
 * <li><a href="https://scc.ustc.edu.cn/zlsc/sugon/intel/ipp/ipp_manual/IPPI/ippi_ch6/ch6_gamma_correction.htm#ch6_gamma_correction">
 *     Intel IPP Gamma Correction</a></li>
 * </ol>
 *
 * @author Peter Abeles
 */
public class ColorXyz {
	// Look up tables for inverse gamma function. Should be faster than computing invGamma
	public final static float[] table_invgamma_f = new float[256];
	public final static double[] table_invgamma_d = new double[256];

	static {
		for (int i = 0; i < table_invgamma_f.length; i++) {
			table_invgamma_d[i] = invGamma(i/255.0);
			table_invgamma_f[i] = (float) table_invgamma_d[i];
		}
	}

	/**
	 * Conversion from 8-bit RGB into XYZ.  8-bit = range of 0 to 255.
	 */
	public static void rgbToXyz( int r , int g , int b , double []xyz ) {
		srgbToXyz(invGamma(r/255.0),invGamma(g/255.0),invGamma(b/255.0),xyz);
	}

	/**
	 * Conversion from 8-bit RGB into XYZ.  8-bit = range of 0 to 255.
	 */
	public static void rgbToXyz( int r , int g , int b , float []xyz ) {
		srgbToXyz((float)invGamma(r/255.0f),(float)invGamma(g/255.0f),(float)invGamma(b/255.0f),xyz);
	}

	/**
	 * Conversion from 8-bit RGB into XYZ.  8-bit = range of 0 to 255.
	 */
	public static void rgbToXyz( double r , double g , double b , float []xyz ) {
		srgbToXyz((float)invGamma(r/255.0f),(float)invGamma(g/255.0f),(float)invGamma(b/255.0f),xyz);
	}

	/**
	 * Conversion of CEI XYZ to 8-bit RGB. Converts to srgb and then applies gamma correction.
	 *
	 * @param srgb (output) Workspace to store intermediate srgb results
	 * @param rgb (output) Output of gamma corrected RGB color 0 to 255
	 */
	public static void xyzToRgb( double x , double y , double z, double[]srgb , int[]rgb ) {
		xyzToSrgb(x,y,z,srgb);
		rgb[0] = (int)(255.0*gamma(srgb[0])+0.5) & 0xFF;
		rgb[1] = (int)(255.0*gamma(srgb[1])+0.5) & 0xFF;
		rgb[2] = (int)(255.0*gamma(srgb[2])+0.5) & 0xFF;
	}

	/**
	 * Conversion of CEI XYZ to 8-bit RGB. Converts to srgb and then applies gamma correction.
	 *
	 * @param srgb (output) Workspace to store intermediate srgb results
	 * @param rgb (output) Output of gamma corrected RGB color 0 to 255
	 */
	public static void xyzToRgb( float x , float y , float z, float[]srgb , int[]rgb ) {
		xyzToSrgb(x,y,z,srgb);
		rgb[0] = (int)(255.0*gamma(srgb[0])+0.5) & 0xFF;
		rgb[1] = (int)(255.0*gamma(srgb[1])+0.5) & 0xFF;
		rgb[2] = (int)(255.0*gamma(srgb[2])+0.5) & 0xFF;
	}

	/**
	 * Conversion of CEI XYZ to 8-bit RGB. Converts to srgb and then applies gamma correction.
	 *
	 * @param srgb (output) Workspace to store intermediate srgb results
	 * @param rgb (output) Output of gamma corrected RGB color.
	 */
	public static void xyzToRgb( float x , float y , float z, float[]srgb , float[]rgb ) {
		xyzToSrgb(x,y,z,srgb);
		rgb[0] = (float)(255.0*gamma(srgb[0]));
		rgb[1] = (float)(255.0*gamma(srgb[1]));
		rgb[2] = (float)(255.0*gamma(srgb[2]));
	}

	/**
	 * Inverse gamma correction function
	 */
	public static double invGamma( double v ) {
		if (v<=0.04045) {
			return(v / 12.92);
		}
		return(Math.pow((v + 0.055) / 1.055,2.4));
	}

	/**
	 * Forward gamma correction function
	 */
	public static double gamma( double v ) {
		if (v<=0.0031308) {
			return (323.0/25.0)*v;
		}
		return (211.0/200.0)*Math.pow(v,5.0/12.0)-(11.0/200.0);
	}

	/**
	 * Conversion from gamma corrected normalized R'G'B' into CEI XYZ.  Normalized RGB values have a range of 0:1
	 */
	public static void srgbToXyz( double r , double g , double b , double []xyz ) {
		xyz[0] = 0.412453*r + 0.35758 *g + 0.180423*b;
		xyz[1] = 0.212671*r + 0.71516 *g + 0.072169*b;
		xyz[2] = 0.019334*r + 0.119193*g + 0.950227*b;
	}

	/**
	 * Conversion from gamma corrected normalized R'G'B' into CEI XYZ.  Normalized RGB values have a range of 0:1
	 */
	public static void srgbToXyz( float r , float g , float b , float []xyz ) {
		xyz[0] = 0.412453f*r + 0.35758f *g + 0.180423f*b;
		xyz[1] = 0.212671f*r + 0.71516f *g + 0.072169f*b;
		xyz[2] = 0.019334f*r + 0.119193f*g + 0.950227f*b;
	}

	/**
	 * Conversion from CEI XYZ to gamma corrected normalized R'G'B'.  Normalized RGB values have a range of 0:1
	 */
	public static void xyzToSrgb( float x , float y , float z , float []srgb ) {
		srgb[0] =  3.240479f*x - 1.53715f*y  - 0.498535f*z;
		srgb[1] = -0.969256f*x + 1.875991f*y + 0.041556f*z;
		srgb[2] =  0.055648f*x - 0.204043f*y + 1.057311f*z;
	}

	/**
	 * Conversion from CEI XYZ to gamma corrected normalized R'G'B'.  Normalized RGB values have a range of 0:1
	 */
	public static void xyzToSrgb( double x , double y , double z , double []srgb ) {
		srgb[0] =  3.240479*x - 1.53715*y  - 0.498535*z;
		srgb[1] = -0.969256*x + 1.875991*y + 0.041556*z;
		srgb[2] =  0.055648*x - 0.204043*y + 1.057311*z;
	}

	/**
	 * Convert a 3-channel {@link Planar} image from RGB into XYZ.  RGB is assumed
	 * to have a range from 0:255
	 *
	 * NOTE: Input and output image can be the same instance.
	 *
	 * @param rgb (Input) RGB encoded image
	 * @param xyz (Output) XYZ encoded image
	 */
	public static  <T extends ImageGray<T>>
	void rgbToXyz(Planar<T> rgb , Planar<GrayF32> xyz ) {
		xyz.reshape(rgb.width,rgb.height,3);

		if( rgb.getBandType() == GrayU8.class ) {
			if (BoofConcurrency.USE_CONCURRENT) {
				ImplColorXyz_MT.rgbToXyz_U8((Planar<GrayU8>) rgb, xyz);
			} else {
				ImplColorXyz.rgbToXyz_U8((Planar<GrayU8>) rgb, xyz);
			}
		} else if( rgb.getBandType() == GrayF32.class ) {
			if(BoofConcurrency.USE_CONCURRENT ) {
				ImplColorXyz_MT.rgbToXyz_F32((Planar<GrayF32>)rgb,xyz);
			} else {
				ImplColorXyz.rgbToXyz_F32((Planar<GrayF32>)rgb,xyz);
			}
		} else {
			throw new IllegalArgumentException("Unsupported band type "+rgb.getBandType().getSimpleName());
		}
	}

	/**
	 * Convert CEI XYZ image to RGB. RGB is assumed to have a range from 0:255
	 *
	 * NOTE: Input and output image can be the same instance.
	 *
	 * @param xyz (Input) XYZ encoded image
	 * @param rgb (Output) RGB encoded image
	 */
	public static  <T extends ImageGray<T>>
	void xyzToRgb(Planar<GrayF32> xyz, Planar<T> rgb ) {
		xyz.reshape(rgb.width,rgb.height,3);

		if( rgb.getBandType() == GrayU8.class ) {
			if (BoofConcurrency.USE_CONCURRENT) {
				ImplColorXyz_MT.xyzToRgb_U8(xyz,(Planar<GrayU8>) rgb);
			} else {
				ImplColorXyz.xyzToRgb_U8(xyz,(Planar<GrayU8>) rgb);
			}
		} else if( rgb.getBandType() == GrayF32.class ) {
			if(BoofConcurrency.USE_CONCURRENT ) {
				ImplColorXyz_MT.xyzToRgb_F32(xyz,(Planar<GrayF32>)rgb);
			} else {
				ImplColorXyz.xyzToRgb_F32(xyz,(Planar<GrayF32>)rgb);
			}
		} else {
			throw new IllegalArgumentException("Unsupported band type "+rgb.getBandType().getSimpleName());
		}
	}
}
