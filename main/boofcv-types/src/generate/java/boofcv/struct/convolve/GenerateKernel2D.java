/*
 * Copyright (c) 2021, Peter Abeles. All Rights Reserved.
 *
 * This file is part of BoofCV (http://boofcv.org).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package boofcv.struct.convolve;

import boofcv.generate.AutoTypeImage;
import boofcv.generate.CodeGeneratorBase;

import java.io.FileNotFoundException;

/**
 * @author Peter Abeles
 */
@SuppressWarnings("OrphanedFormatString")
public class GenerateKernel2D extends CodeGeneratorBase {
	@Override
	public void generateCode() throws FileNotFoundException {
		createFile(AutoTypeImage.F32);
		createFile(AutoTypeImage.F64);
		createFile(AutoTypeImage.S32);
	}

	private void createFile( AutoTypeImage imageType ) throws FileNotFoundException  {
		String suffix = imageType.getAbbreviatedType();
		suffix = suffix.compareTo("S32") == 0 ? "I32" : suffix;
		className = "Kernel2D_"+suffix;

		String sumType = imageType.getSumType();

		setOutputFile(className);
		out.print("/**\n" +
				" * This is a kernel in a 2D convolution. The convolution is performed by\n" +
				" * convolving this kernel across a 2D array/image. The kernel is square and has\n" +
				" * the specified width. To promote reuse of data structures the width of the kernel can be changed.\n" +
				" * All elements in this kernel are floating point numbers.\n" +
				" *\n" +
				" * <p>\n" +
				" * WARNING: Do not modify. Automatically generated by "+getClass().getSimpleName()+".\n" +
				" * </p>\n" +
				" * \n" +
				" * @author Peter Abeles\n" +
				" */\n" +
				"public class " + className + " extends Kernel2D {\n" +
				"\n" +
				"\tpublic " + sumType + " data[];\n" +
				"\n" +
				"\t/**\n" +
				"\t * Creates a new kernel whose initial values are specified by 'data' and 'width'. The length\n" +
				"\t * of its internal data will be width*width. Data must be at least as long as width*width.\n" +
				"\t * The offset is automatically set to width/2\n" +
				"\t *\n" +
				"\t * @param width The kernels width. Must be odd.\n" +
				"\t * @param data  The value of the kernel. Not modified. Reference is not saved.\n" +
				"\t */\n" +
				"\tpublic " + className + "(int width, " + sumType + " []data) {\n" +
				"\t\tsuper(width);\n" +
				"\n" +
				"\t\tthis.data = new " + sumType + "[width * width];\n" +
				"\t\tSystem.arraycopy(data, 0, this.data, 0, this.data.length);\n" +
				"\t}\n" +
				"\n" +
				"\t/**\n" +
				"\t * Create a kernel with elements initialized to zero with the specified 'width' and offset equal to\n" +
				"\t * width/2\n" +
				"\t *\n" +
				"\t * @param width How wide the kernel is.\n" +
				"\t */\n" +
				"\tpublic " + className + "(int width) {\n" +
				"\t\tsuper(width);\n" +
				"\n" +
				"\t\tdata = new " + sumType + "[width * width];\n" +
				"\t}\n" +
				"\n" +
				"\t/**\n" +
				"\t * Create a kernel with elements initialized to zero with the specified 'width' and 'offset'.\n" +
				"\t *\n" +
				"\t * @param width How wide the kernel is.\n" +
				"\t */\n" +
				"\tpublic " + className + "(int width, int offset) {\n" +
				"\t\tsuper(width,offset);\n" +
				"\n" +
				"\t\tdata = new " + sumType + "[width * width];\n" +
				"\t}\n" +
				"\n" +
				"\tprotected " + className + "() {\n" +
				"\t}\n" +
				"\n" +
				"\t/**\n" +
				"\t * Creates a kernel whose elements are the specified data array and has\n" +
				"\t * the specified width.\n" +
				"\t *\n" +
				"\t * @param data  The array who will be the kernel's data. Reference is saved.\n" +
				"\t * @param width The kernel's width.\n" +
				"\t * @param offset Kernel origin's offset from element 0.\n" +
				"\t * @return A new kernel.\n" +
				"\t */\n" +
				"\tpublic static " + className + " wrap(" + sumType + " data[], int width, int offset) {\n" +
				"\t\tif (width % 2 == 0 && width <= 0 && width * width > data.length)\n" +
				"\t\t\tthrow new IllegalArgumentException(\"invalid width\");\n" +
				"\n" +
				"\t\t" + className + " ret = new " + className + "();\n" +
				"\t\tret.data = data;\n" +
				"\t\tret.width = width;\n" +
				"\t\tret.offset = offset;\n" +
				"\n" +
				"\t\treturn ret;\n" +
				"\t}\n" +
				"\n" +
				"\tpublic " + sumType + " get(int x, int y) {\n" +
				"\t\treturn data[y * width + x];\n" +
				"\t}\n" +
				"\n" +
				"\tpublic void set( int x , int y , " + sumType + " value ) {\n" +
				"\t\tdata[y * width + x] = value;\n" +
				"\t}\n" +
				"\n" +
				"\t@Override\n" +
				"\tpublic boolean isInteger() {\n" +
				"\t\treturn "+imageType.isInteger()+";\n" +
				"\t}\n" +
				"\n" +
				"\tpublic " + sumType + "[] getData() {\n" +
				"\t\treturn data;\n" +
				"\t}\n" +
				"\n" +
				"\tpublic " + sumType + " computeSum() {\n" +
				"\t\tint N = width*width;\n" +
				"\t\t" + sumType + " total = 0;\n" +
				"\t\tfor( int i = 0; i < N; i++ ) {\n" +
				"\t\t\ttotal += data[i];\n" +
				"\t\t}\n" +
				"\t\treturn total;\n" +
				"\t}\n" +
				"\n" +
				"\tpublic void print() {\n" +
				"\t\tfor( int i = 0; i < width; i++ ) {\n" +
				"\t\t\tfor( int j = 0; j < width; j++ ) {\n");
		if( imageType.isInteger() )
			out.print("\t\t\t\tSystem.out.printf(\"%6d \", data[i*width+j]);\n");
		else
			out.print("\t\t\t\tSystem.out.printf(\"%15f \", data[i*width+j]);\n");
		out.print("\t\t\t}\n" +
				"\t\t\tSystem.out.println();\n" +
				"\t\t}\n" +
				"\t\tSystem.out.println();\n" +
				"\t}\n" +
				"\n" +
				"\t@Override\n" +
				"\tpublic "+className+" copy() {\n" +
				"\t\t"+className+" ret = new "+className+"(width);\n" +
				"\t\tret.offset = this.offset;\n" +
				"\t\tSystem.arraycopy(data,0,ret.data,0,data.length);\n" +
				"\t\treturn ret;\n" +
				"\t}\n" +
				"\n" +
				"\t@Override\n" +
				"\tpublic double getDouble(int x, int y) {\n" +
				"\t\treturn get(x,y);\n" +
				"\t}\n" +
				"}");

	}

	public static void main( String[] args ) throws FileNotFoundException {
		GenerateKernel2D app = new GenerateKernel2D();
		app.generateCode();
	}
}
